# بهبودهای حرکت نرم سروو - Smart Servo Movement Enhancements

## خلاصه بهبودها

این فایل شامل تمام بهبودهای اعمال شده برای حرکت نرم‌تر سرووها در تمام شرایط است.

## 1. تنظیمات جدید حرکت نرم

### پارامترهای قابل تنظیم
```python
SMOOTH_MOVEMENT_CONFIG = {
    "min_step": 1,           # حداقل گام حرکت (درجه)
    "max_step": 3,           # حداکثر گام حرکت (درجه)
    "min_delay": 0.008,      # حداقل تاخیر بین گام‌ها (ثانیه)
    "max_delay": 0.025,      # حداکثر تاخیر بین گام‌ها (ثانیه)
    "acceleration_steps": 10, # تعداد گام‌های شتاب
    "deceleration_steps": 10, # تعداد گام‌های کاهش سرعت
    "small_movement_threshold": 3,  # آستانه حرکت کوچک (درجه)
    "medium_movement_threshold": 15, # آستانه حرکت متوسط (درجه)
    "large_movement_threshold": 45   # آستانه حرکت بزرگ (درجه)
}
```

## 2. الگوریتم‌های حرکت بهبود یافته

### الف) حرکت نرم استاندارد (`set_angle`)
- **شتاب و کاهش سرعت پیشرفته**: حرکت در سه فاز
  - فاز شتاب: افزایش تدریجی سرعت
  - فاز سرعت ثابت: حرکت با سرعت بهینه
  - فاز کاهش سرعت: کاهش تدریجی سرعت

- **تنظیم پارامترها بر اساس فاصله**:
  - حرکت کوچک (≤15°): سرعت بالا، دقت متوسط
  - حرکت متوسط (15-45°): تعادل سرعت و دقت
  - حرکت بزرگ (>45°): دقت بالا، سرعت کنترل شده

### ب) حرکت فوق نرم (`set_angle_ultra_smooth`)
- **Interpolation پیشرفته**: استفاده از تابع Smoothstep
- **تاخیر متغیر**: تنظیم سرعت بر اساس پیشرفت حرکت
- **حداقل 20 گام**: برای حرکت نرم‌تر

## 3. بهینه‌سازی هوشمند

### الف) تنظیم بر اساس حافظه
```python
if memory_free < 5000:  # کمتر از 5KB
    total_steps = max(10, int(movement_distance * 1.5))
elif memory_free < 10000:  # کمتر از 10KB
    total_steps = max(15, int(movement_distance * 1.8))
else:  # حافظه کافی
    total_steps = max(20, int(movement_distance * 2))
```

### ب) تنظیم بر اساس دما
- دمای بالا (>50°C): کاهش سرعت 20%
- دمای پایین (<20°C): افزایش سرعت 10%

### ج) یادگیری از تجربه
- ثبت موفقیت/عدم موفقیت حرکات قبلی
- تنظیم خودکار پارامترها بر اساس عملکرد

## 4. توقف اضطراری نرم

### الف) توقف فوری (`emergency_stop`)
- توقف فوری در موقعیت فعلی

### ب) توقف نرم (`emergency_stop_smooth`)
- کاهش تدریجی سرعت در 5 گام
- استفاده از interpolation برای توقف طبیعی

## 5. دستورات جدید

### الف) `servo_smooth`
- دستور اختصاصی برای حرکت فوق نرم
- همیشه از الگوریتم `set_angle_ultra_smooth` استفاده می‌کند

### ب) `emergency_stop_smooth`
- توقف اضطراری نرم
- کاهش تدریجی سرعت به جای توقف فوری

## 6. انتخاب خودکار نوع حرکت

### منطق انتخاب:
```python
# استفاده از حرکت فوق نرم برای تغییرات بزرگ
use_ultra_smooth = (movement_distance1 > 20 or movement_distance2 > 20)

if use_ultra_smooth:
    # حرکت فوق نرم
    servo1_task = asyncio.create_task(servo1.set_angle_ultra_smooth(...))
else:
    # حرکت نرم استاندارد
    servo1_task = asyncio.create_task(servo1.set_angle(...))
```

## 7. بهبودهای مدیریت خطا

### الف) توقف اضطراری نرم در خطاها
- تلاش برای توقف نرم در صورت خطا
- بازگشت به توقف فوری در صورت عدم موفقیت

### ب) ثبت و پیگیری خطاها
- ثبت موفقیت/عدم موفقیت هر حرکت
- استفاده از اطلاعات برای بهینه‌سازی آینده

## 8. مزایای بهبودها

### الف) حرکت طبیعی‌تر
- شتاب و کاهش سرعت طبیعی
- کاهش ارتعاش و لرزش

### ب) دقت بالاتر
- تنظیم دقیق‌تر زاویه نهایی
- کاهش خطای موقعیت

### ج) انعطاف‌پذیری
- تنظیم خودکار بر اساس شرایط
- پشتیبانی از انواع مختلف حرکت

### د) پایداری
- مدیریت بهتر حافظه
- توقف ایمن در شرایط اضطراری

## 9. نحوه استفاده

### الف) حرکت عادی
```json
{
    "type": "servo",
    "command": {
        "servo1": 90,
        "servo2": 45
    }
}
```

### ب) حرکت فوق نرم
```json
{
    "type": "servo_smooth",
    "command": {
        "servo1": 90,
        "servo2": 45
    }
}
```

### ج) توقف اضطراری نرم
```json
{
    "type": "action",
    "command": {
        "action": "emergency_stop_smooth"
    }
}
```

## 10. نکات مهم

1. **حافظه**: سیستم به طور خودکار تعداد گام‌ها را بر اساس حافظه آزاد تنظیم می‌کند
2. **دما**: در دمای بالا، سرعت حرکت کاهش می‌یابد
3. **فاصله**: حرکت‌های بزرگ به طور خودکار از الگوریتم فوق نرم استفاده می‌کنند
4. **خطا**: در صورت خطا، سیستم به طور خودکار توقف نرم را امتحان می‌کند

## نتیجه‌گیری

این بهبودها باعث حرکت نرم‌تر، طبیعی‌تر و دقیق‌تر سرووها در تمام شرایط می‌شود. سیستم به طور خودکار بهترین الگوریتم را بر اساس شرایط انتخاب کرده و عملکرد را بهینه می‌کند. 